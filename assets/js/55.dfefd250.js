(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{471:function(e,t,o){"use strict";o.r(t);var a=o(32),s=Object(a.a)({},(function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("h1",{attrs:{id:"contract-deployment"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#contract-deployment"}},[e._v("#")]),e._v(" Contract deployment")]),e._v(" "),o("p",[e._v("To maintain the same security as in L1, the zkSync operator must publish on the Ethereum chain the contract code for each contract it deploys. However, if there are multiple contracts deployed with the same code, it will only publish it once.")]),e._v(" "),o("p",[e._v("While deploying contracts for the first time may be relatively expensive, factories, which deploy contracts with the same code multiple times, can have huge savings compared to L1.")]),e._v(" "),o("p",[e._v("All these specifics make the process of deploying smart contracts on zkEVM comply with the major rule: "),o("em",[e._v("The operator should know the code of the contract before it is deployed")]),e._v(". This means that deploying contracts is only possible by the means of "),o("code",[e._v("EIP712")]),e._v(" transactions with the "),o("code",[e._v("factory_deps")]),e._v(" field containing the supplied bytecode. More on EIP712 transactions "),o("RouterLink",{attrs:{to:"/api/api.html#eip712"}},[e._v("here")]),e._v(".")],1),e._v(" "),o("p",[e._v("Summary:")]),e._v(" "),o("ul",[o("li",[o("p",[o("strong",[e._v("How deploying contracts works on Ethereum.")]),e._v("\nTo deploy a contract, a user sends a transaction to the zero address ("),o("code",[e._v("0x000...000")]),e._v(") with the "),o("code",[e._v("data")]),e._v(" field of the transaction equal to the contract bytecode concatenated with the constructor parameters.")])]),e._v(" "),o("li",[o("p",[o("strong",[e._v("How deploying contracts works on zkSync.")]),e._v("\nTo deploy a contract, a user calls the "),o("code",[e._v("create")]),e._v(" function of the "),o("RouterLink",{attrs:{to:"/dev/developer-guides/contracts/system-contracts.html#contractdeployer"}},[e._v("ContractDeployer")]),e._v(" and provides the hash of the contract to be published, as well as the constructor arguments. The contract bytecode itself is supplied in the "),o("code",[e._v("factory_deps")]),e._v(" field of the EIP712 transactions. If the contract is a factory (i.e. it can deploy other contracts), these contracts' bytecodes should be included in the "),o("code",[e._v("factory_deps")]),e._v(" as well.")],1)])]),e._v(" "),o("p",[e._v("The "),o("a",{attrs:{href:"../../../api/hardhat"}},[e._v("hardhat-zksync-deploy")]),e._v(" plugin takes care of the deployment process. Here's a "),o("RouterLink",{attrs:{to:"/api/hardhat/getting-started.html"}},[e._v("guide on how to use it")]),e._v(".")],1),e._v(" "),o("h2",{attrs:{id:"solidity-vyper-support"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#solidity-vyper-support"}},[e._v("#")]),e._v(" Solidity/Vyper support")]),e._v(" "),o("p",[e._v("Compiling Solidity to zkEVM bytecode requires a special compiler. For the time being Solidity "),o("code",[e._v(">=0.4.10")]),e._v(" versions are supported, though we strongly recommended using "),o("code",[e._v("^0.8.0")]),e._v(" as the most stable one. Vyper "),o("code",[e._v("^0.3.3")]),e._v(" is also supported.")]),e._v(" "),o("p",[e._v("Although, older versions of Solidity are supported, here are some of their limitations in zkSync:")]),e._v(" "),o("ul",[o("li",[e._v("Contract-local recursion is not supported.")]),e._v(" "),o("li",[e._v("Internal function pointers are not supported.")])]),e._v(" "),o("p",[e._v("For smart contract compilation using Solidity or Vyper, "),o("RouterLink",{attrs:{to:"/api/hardhat/plugins.html"}},[e._v("check the correspondent Hardhat plugins here")]),e._v(".")],1),e._v(" "),o("p",[e._v("Ethereum cryptographic primitives like "),o("code",[e._v("ecrecover")]),e._v(", "),o("code",[e._v("keccak256")]),e._v(" and "),o("code",[e._v("sha256")]),e._v(" are supported as precompiles. No actions are required from your side as all the calls to the precompiles are done by the compiler under the hood.")]),e._v(" "),o("h2",{attrs:{id:"differences-in-create-behaviour"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#differences-in-create-behaviour"}},[e._v("#")]),e._v(" Differences in "),o("code",[e._v("CREATE")]),e._v(" behaviour")]),e._v(" "),o("p",[e._v("For the ease of supporting account abstraction, for each account, we split the nonce into two parts: "),o("em",[e._v("the deployment nonce")]),e._v(" and "),o("em",[e._v("the transaction nonce")]),e._v(". The deployment nonce is the number of contracts the account has deployed with "),o("code",[e._v("CREATE")]),e._v(" opcode, while the transaction nonce is used for replay attack protection for the transactions.")]),e._v(" "),o("p",[e._v("This means that while for smart contracts the nonce on zkSync behaves the same way as on Ethereum, for EOAs calculating the address of the deployed contract is not as straightforward. On Ethereum, it can be safely calculated as "),o("code",[e._v("hash(RLP[address, nonce])")]),e._v(", while on zkSync it is recommended to wait until the contract is deployed and catch the event with the address of the newly deployed contract. All of this is done in the background by the SDK.\nTo gain a deterministic address, you should use "),o("code",[e._v("create2")]),e._v(". It is available for EOAs as well, but it is not available in the SDK yet.")]),e._v(" "),o("h2",{attrs:{id:"note-on-factory-deps"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#note-on-factory-deps"}},[e._v("#")]),e._v(" Note on "),o("code",[e._v("factory deps")])]),e._v(" "),o("p",[e._v("Under the hood, zkSync stores not bytecodes of contracts, but "),o("a",{attrs:{href:"#format-of-bytecode-hash"}},[e._v("specially formatted")]),e._v(" hashes of their bytecodes. You can see that even the "),o("RouterLink",{attrs:{to:"/dev/developer-guides/contracts/system-contracts.html#contractdeployer"}},[e._v("ContractDeployer")]),e._v(" system contract accepts the bytecode hash of the deployed contract and not its bytecode. However, for contract deployment to succeed, the operator needs to know the bytecode. Exactly for this reason the "),o("code",[e._v("factory_deps")]),e._v(' (i.e. factory dependencies) field for transactions is used: it contains the bytecodes that should be known to the operator in order for this transaction to succeed. Once the transaction succeeds, these bytecodes will be published on L1 and will be considered as "known" to the operator forever.')],1),e._v(" "),o("p",[e._v("Some examples of usage are:\nThe obvious one is when you deploy a contract, you need to provide its code in the "),o("code",[e._v("factory_deps")]),e._v(" field.")]),e._v(" "),o("ul",[o("li",[e._v("On zkSync, factories (i.e. contracts that can deploy other contracts) do not store bytecodes of their dependencies, i.e. contracts that they can deploy. They only store their hashes. That's why you need to include "),o("em",[e._v("all")]),e._v(" the bytecodes of the dependencies in the "),o("code",[e._v("factory_deps")]),e._v(" field.")])]),e._v(" "),o("p",[e._v("Both of these examples are already seamlessly done under the hood by our "),o("RouterLink",{attrs:{to:"/api/hardhat/getting-started.html"}},[e._v("hardhat plugin")]),e._v(".")],1),e._v(" "),o("p",[e._v("Note, that the factory deps do not necessarily have to be used by the transaction in any way. These are just markers that these bytecodes should be published on L1 with this transaction. If your contract contains a lot of various factory dependencies and they do not fit inside a single L1 block, you can split the list of factory dependencies between multiple transactions.")]),e._v(" "),o("p",[e._v("For example, let's say that you want to deploy contract "),o("code",[e._v("A")]),e._v(" which can also deploy contracts "),o("code",[e._v("B")]),e._v(" and "),o("code",[e._v("C")]),e._v(". This means that you will have three factory dependencies for your deployment transaction: "),o("code",[e._v("A")]),e._v(","),o("code",[e._v("B")]),e._v(" and "),o("code",[e._v("C")]),e._v(". If the pubdata required to publish all of them is too large to fit into one block, you can send a dummy transaction with only factory dependencies "),o("code",[e._v("A")]),e._v(" and "),o("code",[e._v("B")]),e._v(" (assuming their combined length is small enough) and do the actual deploy with a second transaction while providing the bytecode of contract "),o("code",[e._v("C")]),e._v(" as a factory dependency for it. Note, that if some contract "),o("em",[e._v("on its own")]),e._v(" is larger than the allowed limit per block, this contract has to be split into smaller ones.")]),e._v(" "),o("h3",{attrs:{id:"l1-l2-communication"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#l1-l2-communication"}},[e._v("#")]),e._v(" L1->L2 communication")]),e._v(" "),o("p",[e._v("The "),o("a",{attrs:{href:"https://github.com/matter-labs/v2-testnet-contracts/blob/d4a2869ab6feadb396f357e55aa41d137adc0ab0/l1/contracts/zksync/interfaces/IMailbox.sol#L76",target:"_blank",rel:"noopener noreferrer"}},[e._v("interface"),o("OutboundLink")],1),e._v(" for submitting L1->L2 transactions accepts the list of all the factory dependencies required for this particular transaction. The logic for working with them is the same as for the L2 transactions. The only difference is that since the user has already published the full preimage for the bytecodes on L1, there is no need to publish these bytecodes again on L1.")]),e._v(" "),o("h3",{attrs:{id:"format-of-bytecode-hash"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#format-of-bytecode-hash"}},[e._v("#")]),e._v(" Format of bytecode hash")]),e._v(" "),o("p",[e._v("Each zkEVM bytecode must adhere to the following format:")]),e._v(" "),o("ul",[o("li",[e._v("Its length must be divisible by 32.")]),e._v(" "),o("li",[e._v("Its length in words (32-byte chunks) should be odd. In other words, "),o("code",[e._v("bytecodeLength % 64 == 32")]),e._v(".")]),e._v(" "),o("li",[e._v("It can not be longer than "),o("code",[e._v("2^16")]),e._v(" 32-byte words, i.e. "),o("code",[e._v("2^21")]),e._v(" bytes.")])]),e._v(" "),o("p",[e._v("The 32-byte hash of the bytecode of a zkSync contract is calculated in the following way:")]),e._v(" "),o("ul",[o("li",[e._v("The first 2 bytes denote the version of bytecode hash format and are currently equal to "),o("code",[e._v("[1,0]")]),e._v(".")]),e._v(" "),o("li",[e._v("The second 2 bytes denote the length of the bytecode in 32-byte words.")]),e._v(" "),o("li",[e._v("The rest of the 28-byte (i.e. 28 low big-endian bytes) are equal to the last 28 bytes of the "),o("code",[e._v("sha256")]),e._v(" hash of the contract's bytecode.")])])])}),[],!1,null,null,null);t.default=s.exports}}]);