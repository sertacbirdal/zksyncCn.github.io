(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{468:function(e,t,s){"use strict";s.r(t);var a=s(32),n=Object(a.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"blocks"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#blocks"}},[e._v("#")]),e._v(" Blocks")]),e._v(" "),s("p",[e._v("A block is an ordered list of transactions. Each block (except for the Genesis block) points to the previous block it extends, thus creating a chain of blocks.")]),e._v(" "),s("h2",{attrs:{id:"blocks-in-zksync-2-0"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#blocks-in-zksync-2-0"}},[e._v("#")]),e._v(" Blocks in zkSync 2.0")]),e._v(" "),s("p",[e._v('In zkSync there are two notions of "blocks": an L2 block and an L1 rollup block.')]),e._v(" "),s("p",[e._v('L2 blocks, or just "blocks", are simply the blocks created on L2, that is on the zkSync network. They are not included on the Ethereum chain. An L1 rollup block, which we call "batch", is a set of\nconsecutive (L2) blocks, it contains all the transactions, and in the same order, from the first block in the batch to the last block in the\nbatch.')]),e._v(" "),s("p",[e._v("L1 batches, as the name suggests, are submitted to Ethereum. The main reason to have these different notions is that a block can\ncontain a minimal number of transactions, and thus be processed quickly, while in a batch we would like to include many transactions, to make the cost of interaction with L1 spread among many transactions.")]),e._v(" "),s("h2",{attrs:{id:"block-numbers"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#block-numbers"}},[e._v("#")]),e._v(" Block numbers")]),e._v(" "),s("p",[e._v("Accessing block numbers within zkSync API is similar to how you would do it on Ethereum. For example, "),s("code",[e._v("eth_blockNumber")]),e._v(" returns the number\nof the latest L2 block, and "),s("code",[e._v("eth_getBlockByNumber")]),e._v(", given a block number, returns the information about the requested block.")]),e._v(" "),s("p",[e._v("For L1 batches, to retrieve the latest batch number, use zkSync API method "),s("code",[e._v("zks_L1BatchNumber")]),e._v(".\nAdditionally, by querying on a block, you can see the batch number for the batch that includes the block.\nWithin transaction receipts, the field "),s("code",[e._v("l1BatchNumber")]),e._v(" is the batch number that includes the transaction.\nThe field "),s("code",[e._v("l1BatchTxIndex")]),e._v(" returns the transaction position among all of the batch transactions.")]),e._v(" "),s("h2",{attrs:{id:"block-processing-time"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#block-processing-time"}},[e._v("#")]),e._v(" Block processing time")]),e._v(" "),s("p",[e._v("Transactions are processed immediately by the operator and added to blocks, which are then immediately generated. Once zkSync becomes\nfully decentralised, block time will take a couple of seconds, as the involved entities need to achieve consensus.")]),e._v(" "),s("p",[e._v("Batch time, in general, depends on the system activity - the more active the system has, the faster we "),s("em",[e._v("seal")]),e._v(" a batch.\nThere are several criteria for sealing a batch, which we defer from explaining in detail here, as the system is still under testing and\nthese may change.\nIn general, a batch will get sealed when:")]),e._v(" "),s("ol",[s("li",[e._v('The batch "capacity" is reached. Capacity includes L1 gas used, L2 ergs consumed and several other parameters.')]),e._v(" "),s("li",[e._v("The batch timeout has passed.")])]),e._v(" "),s("p",[e._v("After submitting transactions, users can check where in the process their transaction is as explained "),s("RouterLink",{attrs:{to:"/dev/fundamentals/zkSync.html#zksync-overview"}},[e._v("here")]),e._v(".")],1),e._v(" "),s("h3",{attrs:{id:"hashes"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashes"}},[e._v("#")]),e._v(" Hashes")]),e._v(" "),s("p",[e._v('Block hashes in zkSync are deterministic and are derived from the following formula: "keccak256(l2_block_number)".\nThe reason for having a deterministic block hash is that these hashes are not provable (remember that L2 blocks are not submitted to L1).\nProjects are advised not to use the L2 block hash as a source of randomness.')]),e._v(" "),s("h3",{attrs:{id:"block-properties"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#block-properties"}},[e._v("#")]),e._v(" Block Properties")]),e._v(" "),s("ul",[s("li",[e._v("Timestamp: The current block's creation time in seconds that returns the timestamp of the L1 batch.")]),e._v(" "),s("li",[e._v("Block number: The unique sequential number for this block.")]),e._v(" "),s("li",[e._v("Gas limit: The current block gas limit, always returns "),s("code",[e._v("2^32-1")]),e._v(".")]),e._v(" "),s("li",[e._v("Coinbase:  The current block minerâ€™s address, returns the "),s("RouterLink",{attrs:{to:"/dev/developer-guides/contracts/system-contracts.html#bootloader"}},[e._v("bootloader")]),e._v(" address.")],1),e._v(" "),s("li",[e._v("Difficulty: The current block difficulty, returns "),s("code",[e._v("2500000000000000")]),e._v(" (zkSync does not have proof of work consensus).")])])])}),[],!1,null,null,null);t.default=n.exports}}]);