(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{459:function(v,_,t){"use strict";t.r(_);var e=t(32),a=Object(e.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"桥接资产"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#桥接资产"}},[v._v("#")]),v._v(" 桥接资产")]),v._v(" "),t("h2",{attrs:{id:"介绍"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#介绍"}},[v._v("#")]),v._v(" 介绍")]),v._v(" "),t("p",[v._v("桥接是通过让两个合约（一个部署到 L1，第二个部署到 L2）使用 "),t("RouterLink",{attrs:{to:"/dev/developer-guides/bridging/l1-l2-interop.html"}},[v._v("L1 <-> L2 互操作性")]),v._v("互相通信。")],1),v._v(" "),t("p",[v._v("开发人员可以自由地为任何代币构建自己的桥接合约。\n不过，我们提供了默认桥接合约(一个用于 ETH，一个用于 ERC20 代币)，它们可以用于基础桥接。")]),v._v(" "),t("p",[v._v("::: 注意")]),v._v(" "),t("p",[v._v("L2 上的代币合约地址始终不同于相同代币名称的 L1 合约地址。")]),v._v(" "),t("p",[v._v(":::")]),v._v(" "),t("h2",{attrs:{id:"默认桥接合约"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#默认桥接合约"}},[v._v("#")]),v._v(" 默认桥接合约")]),v._v(" "),t("p",[v._v("您可以使用我们的 JS SDK 中的 "),t("code",[v._v("zks_getBridgeContracts")]),v._v(" 端点或 "),t("code",[v._v("Provider")]),v._v(" 的 "),t("code",[v._v("getDefaultBridgeAddresses")]),v._v(" 方法获取默认桥接合约的地址（其他 SDK 中也有类似的方法）。")]),v._v(" "),t("h3",{attrs:{id:"存入-至-l2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#存入-至-l2"}},[v._v("#")]),v._v(" 存入（至 L2）")]),v._v(" "),t("p",[v._v("用户必须在 L1 桥接合约上调用 "),t("code",[v._v("deposit")]),v._v(" 模块，这将触发以下操作:")]),v._v(" "),t("ul",[t("li",[v._v("用户的 L1 代币将被发送到 L1 桥接合约，并锁定在那里。")]),v._v(" "),t("li",[v._v("L1 桥接合约使用 L1->L2 通信向 L2 桥接合约发起交易。")]),v._v(" "),t("li",[v._v("在 L2 交易中，代币将被铸造并被发送到 L2 的指定地址。\n"),t("ul",[t("li",[v._v("如果该代币在 zkSync 上还不存在，就会为其部署一个新的合约。如果 L2 代币地址是确定的（基于原始 L1 地址、名称和符号），那么谁是第一个桥接它的人并不重要，新的 L2 地址将是相同的。")])])]),v._v(" "),t("li",[v._v("对于每一个执行的 L1 -> L2 交易，将有一条 L2 -> L1 日志消息确认其执行。")])]),v._v(" "),t("p",[v._v("::: 注意")]),v._v(" "),t("p",[v._v("如果此交易因某种原因失败（例如，提供的费用太低），日志消息将说明其失败。在这种情况下，可以在 L1 桥接合约上通过调用 "),t("code",[v._v("claimFailedDeposit")]),v._v(" 模块来证明日志包含（log inclusion），将存入的资金返回给原始发送方。")]),v._v(" "),t("p",[v._v(":::")]),v._v(" "),t("p",[v._v("上面描述的日志消息还没有被我们的 SDK 完全支持，但是在 L1 桥接合约上是可用的。")]),v._v(" "),t("h3",{attrs:{id:"提取-到-l1"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#提取-到-l1"}},[v._v("#")]),v._v(" 提取（到 L1）")]),v._v(" "),t("p",[v._v("用户必须在 L2 桥接合约上调用 "),t("code",[v._v("withdraw")]),v._v(" 模块，这将触发以下操作:")]),v._v(" "),t("ul",[t("li",[v._v("L2 代币将被销毁。")]),v._v(" "),t("li",[v._v("将发送一条 L2 -> L1 信息，其中包含有关提取的信息。")]),v._v(" "),t("li",[v._v("之后，L1 桥接合约中的任何人都可以完成提取操作(通过证明包含 L2 -> L1 消息，这是在调用 L1 桥接合约上的 "),t("code",[v._v("finlizeWithdraw")]),v._v(" 模块时完成的)。")]),v._v(" "),t("li",[v._v("调用该模块后，资金从 L1 桥接合约中解锁并发送给提取接收者。")])]),v._v(" "),t("p",[v._v("::: 注意")]),v._v(" "),t("p",[v._v("在测试网环境下，我们会自动完成所有的提取交易。也就是说，对于每一笔提取交易，我们都会通过进行 L1 交易来处理，证明每条信息包含。")]),v._v(" "),t("p",[v._v(":::")])])}),[],!1,null,null,null);_.default=a.exports}}]);