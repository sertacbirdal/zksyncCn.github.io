(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{468:function(v,_,t){"use strict";t.r(_);var e=t(32),a=Object(e.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"合约部署"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#合约部署"}},[v._v("#")]),v._v(" 合约部署")]),v._v(" "),t("p",[v._v("为了保持与 L1 相同的安全性，zkSync 运营者必须在以太坊链上发布其部署的每个合约的合约代码。如果有多个使用相同代码部署的合约，那么它只会发布一次。")]),v._v(" "),t("p",[v._v("虽然第一次部署合同可能相对昂贵，但多次部署相同代码的合约的工厂(factory，即可以部署其他合约的合约)，与 L1 相比，可以节省大量的费用。")]),v._v(" "),t("p",[v._v("这些特性让通过 zkEVM 部署智能合约的过程遵循一个主要规则："),t("em",[v._v("在部署合约之前，运营者应该知道合约的代码")]),v._v("。这意味着只能通过 "),t("code",[v._v("EIP712")]),v._v(" 交易的方式部署合约，其中 "),t("code",[v._v("factory_deps")]),v._v(" 字段中包含所提供的字节码。有关 EIP712 交易的更多信息，请通过"),t("RouterLink",{attrs:{to:"/api/api.html#eip712"}},[v._v("这里")]),v._v("了解。")],1),v._v(" "),t("p",[v._v("概要：")]),v._v(" "),t("ul",[t("li",[t("p",[t("strong",[v._v("如何在以太坊上部署合约")])])]),v._v(" "),t("li",[t("p",[v._v("用户将一个交易发送到零地址("),t("code",[v._v("0x000…000")]),v._v(")用于部署合约，交易的 "),t("code",[v._v("data")]),v._v(" 字段等于连接到构造函数参数的合约字节码。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("如何在 zkSync 上部署合约")])])]),v._v(" "),t("li",[t("p",[v._v("要部署合约，用户调用 "),t("RouterLink",{attrs:{to:"/dev/developer-guides/contracts/system-contracts.html#contractdeployer"}},[v._v("ContractDeployer")]),v._v(" 的 "),t("code",[v._v("create")]),v._v(" 函数并提供要发布的合约的哈希值以及构造函数参数。合约字节码在 EIP712 交易的“factory_deps”字段中提供。如果合约是一个工厂（即它可以部署其他合约），这些合约的字节码也应该包含在 "),t("code",[v._v("factory_deps")]),v._v(" 中。")],1)])]),v._v(" "),t("p",[t("a",{attrs:{href:"../../../api/hardhat"}},[v._v("Hardhat-zksync-deploy")]),v._v(" 插件负责合约部署过程。这里有一个"),t("RouterLink",{attrs:{to:"/api/hardhat/getting-started.html"}},[v._v("关于如何使用它的指南")]),v._v("。")],1),v._v(" "),t("h2",{attrs:{id:"solidity-vyper-支持"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#solidity-vyper-支持"}},[v._v("#")]),v._v(" Solidity/Vyper 支持")]),v._v(" "),t("p",[v._v("将 Solidity 编译成 zkEVM 字节码需要一个特殊的编译器。目前支持 Solidity "),t("code",[v._v(">=0.4.10")]),v._v(" 版本，尽管我们强烈建议使用"),t("code",[v._v("^0.8.0")]),v._v("作为最稳定的版本。Vyper "),t("code",[v._v("^0.3.3")]),v._v("也是支持的。")]),v._v(" "),t("p",[v._v("尽管支持旧版本的 Solidity，但在 zkSync 中，它们有一些限制：")]),v._v(" "),t("ul",[t("li",[v._v("不支持 Contract-local 递归。")]),v._v(" "),t("li",[v._v("不支持内部函数指针。")])]),v._v(" "),t("p",[v._v("如需使用 Solidity 或 Vyper 编译智能合约，可在这里查找相应的"),t("RouterLink",{attrs:{to:"/api/hardhat/plugins.html"}},[v._v(" Hardhat 插件")]),v._v("。")],1),v._v(" "),t("p",[v._v("以太坊加密的原语，如 "),t("code",[v._v("ecrecover")]),v._v("，"),t("code",[v._v("keccak256")]),v._v(" 和 "),t("code",[v._v("sha256")]),v._v(" 支持预编译。您不需要任何操作，因为所有对预编译的调用都是由编译器在底层完成的。")]),v._v(" "),t("h2",{attrs:{id:"create-行为的差异"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#create-行为的差异"}},[v._v("#")]),v._v(" "),t("code",[v._v("CREATE")]),v._v(" 行为的差异")]),v._v(" "),t("p",[v._v("为了便于支持账户抽象，对于每个账户，我们将 nonce 分为两个部分: "),t("em",[v._v("deployment nonce")]),v._v(" 与 "),t("em",[v._v("transaction nonce")]),v._v("。Deployment nonce 是账户使用 "),t("code",[v._v("CREATE")]),v._v(" 操作码部署的智能合约数量，而 transaction nonce 用于对交易的重放攻击保护。")]),v._v(" "),t("p",[v._v("这意味着对于智能合约来说，zkSync 上的 nonce 与以太坊上的行为相同，但对于 EOAs 来说，计算部署合约的地址就不那么简单了。在以太坊上，它可以安全地计算为 "),t("code",[v._v("hash(RLP[address, nonce])")]),v._v("，而在 zkSync 上，建议等待合约部署完成，并使用新部署的合约地址抓取活动。这些都是由 SDK 在底层完成的。\n要获得一个确定的地址，您应该使用 "),t("code",[v._v("create2")]),v._v(" 来创建合约。它也可以用于 EOAs，但在 SDK 中尚不可用。")]),v._v(" "),t("h2",{attrs:{id:"关于-factory-deps-的注意事项"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#关于-factory-deps-的注意事项"}},[v._v("#")]),v._v(" 关于 "),t("code",[v._v("factory deps")]),v._v(" 的注意事项")]),v._v(" "),t("p",[v._v("一些用法的例子:\n最明显的一个例子是，在部署合约时，需要在 "),t("code",[v._v("factory deps")]),v._v(" 字段中提供它的代码。")]),v._v(" "),t("ul",[t("li",[v._v("在 zkSync 上，工厂不存储它们依赖项的字节码，即它们可以部署的合约。它们只存储哈希值。这就是为什么您需要在 "),t("code",[v._v("factory_deps")]),v._v(" 字段中包含"),t("em",[v._v("所有")]),v._v("依赖的字节码。")])]),v._v(" "),t("p",[v._v("在底层逻辑中，zkSync存储的不是合同的字节码，而是其字节码的"),t("a",{attrs:{href:"#format-of-bytecode-hash"}},[v._v("特殊格式化")]),v._v("哈希值。你可以看到，即使是"),t("RouterLink",{attrs:{to:"/dev/developer-guides/contracts/system-contracts.html#contractdeployer"}},[v._v("ContractDeployer")]),v._v("系统合同也接受部署合同的字节码哈希值，而不是它的字节码。然而，为了使合约部署成功，运营商需要知道字节码。正是由于这个原因，交易的"),t("code",[v._v("factory_deps")]),v._v('（即工厂依赖）字段被使用：它包含了操作员应该知道的字节码，以便这个交易成功。一旦交易成功，这些字节码将被公布在L1上，并被视为永远被操作者 "知道"。')],1),v._v(" "),t("p",[v._v("这两个例子已经通过我们的 "),t("RouterLink",{attrs:{to:"/api/hardhat/plugins.html"}},[v._v(" Hardhat 插件")]),v._v("在底层无缝完成。")],1),v._v(" "),t("p",[v._v("请注意，factory_deps 不一定必须以某种方式由交易调用。这些只是标记，表明这些字节码应该和这个交易一起发布到 L1 上。如果您的合约包含许多不同的工厂依赖项并且它们不适合单个 L1 区块，您可以在多个交易之间拆分工厂依赖项的列表。")]),v._v(" "),t("p",[v._v("例如，如果您想部署合约 "),t("code",[v._v("A")]),v._v("，它也可以部署合约 "),t("code",[v._v("B")]),v._v(" 和 "),t("code",[v._v("C")]),v._v("。这意味着您将有三个工厂依赖项来部署交易："),t("code",[v._v("A")]),v._v("、"),t("code",[v._v("B")]),v._v(" 和 "),t("code",[v._v("C")]),v._v("。如果发布它们所需的 pubdata 太大，无法放入同一个区块中，您可以发送一个只包含工厂依赖项 "),t("code",[v._v("A")]),v._v(" 和 "),t("code",[v._v("B")]),v._v(" 的虚拟交易(假设它们的总长度足够小)，并使用第二个交易进行实际部署，同时提供合约 "),t("code",[v._v("C")]),v._v(" 的字节码作为工厂依赖项。注意，如果某个合约"),t("em",[v._v("本身")]),v._v("大于每个区块允许的限制，则必须将该合约拆分为更小的合约。")]),v._v(" "),t("h3",{attrs:{id:"l1-l2-通信"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#l1-l2-通信"}},[v._v("#")]),v._v(" L1->L2 通信")]),v._v(" "),t("p",[v._v("提交 L1->L2 交易的"),t("a",{attrs:{href:"https://github.com/matter-labs/v2-testnet-contracts/blob/d4a2869ab6feadb396f357e55aa41d137adc0ab0/l1/contracts/zksync/interfaces/IMailbox.sol#L76",target:"_blank",rel:"noopener noreferrer"}},[v._v("接口"),t("OutboundLink")],1),v._v("接受这个特定交易所需的所有工厂依赖项的列表。处理它们的逻辑与处理 L2 交易的逻辑相同。唯一的区别是，由于用户已经在 L1 上发布了字节码的完整映像，所以不需要在 L1 上再次发布这些字节码。")]),v._v(" "),t("h3",{attrs:{id:"字节码哈希值的格式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#字节码哈希值的格式"}},[v._v("#")]),v._v(" 字节码哈希值的格式")]),v._v(" "),t("p",[v._v("每个 zkEVM 字节码必须符合以下格式:")]),v._v(" "),t("ul",[t("li",[v._v("其长度必须能被 32 整除。")]),v._v(" "),t("li",[v._v("它的长度（32 字节块）应该是奇数。换句话说，"),t("code",[v._v("bytecodeLength % 64 == 32")]),v._v("。")]),v._v(" "),t("li",[v._v("它不能长于 "),t("code",[v._v("2^16")]),v._v("32 字节的字，也就是 "),t("code",[v._v("2^21")]),v._v(" 字节。")])]),v._v(" "),t("p",[v._v("zkSync 合约字节码的 32 字节哈希值计算方法如下:")]),v._v(" "),t("ul",[t("li",[v._v("前两个字节表示字节码哈希值格式的版本，目前等于 "),t("code",[v._v("[1,0]")]),v._v("。")]),v._v(" "),t("li",[v._v("第二个 2 字节表示字节码的长度，以 32 字节为单位。")]),v._v(" "),t("li",[v._v("其余 28 字节（即 28 个低位大端序字节）等于 "),t("code",[v._v("sha256")]),v._v(" 合约字节码哈希值的最后 28 个字节。")])])])}),[],!1,null,null,null);_.default=a.exports}}]);