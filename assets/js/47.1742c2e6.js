(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{456:function(v,_,t){"use strict";t.r(_);var e=t(32),r=Object(e.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"l1-l2-的互操作性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#l1-l2-的互操作性"}},[v._v("#")]),v._v(" L1 / L2 的互操作性")]),v._v(" "),t("p",[v._v("虽然大部分执行将发生在 L2 上，但某些用例需要与 L1 链的互操作性。 主要用例是构建复杂的桥梁，在一条链上维护治理智能合约以管理其他链上的合约等。")]),v._v(" "),t("p",[v._v("此外，L2 的抗审查性来源于底层链，因此从以太坊向 zkSync 发送消息的能力是称为 "),t("a",{attrs:{href:"#priority-queue"}},[v._v("priority queue")]),v._v(" 抗审查机制的重要组成部分。")]),v._v(" "),t("p",[v._v("从以太坊向 zkSync 发送交易是通过 zkSync 智能合约完成的。 它允许发送方直接从 L1 请求交易。 从而允许将任何数据从以太坊未经许可地传递到 zkSync。\n"),t("RouterLink",{attrs:{to:"/dev/developer-guides/bridging/l1-l2.html"}},[v._v("阅读更多")]),v._v(" 关于从 L1 到 L2 的消息传递。")],1),v._v(" "),t("h2",{attrs:{id:"优先队列"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#优先队列"}},[v._v("#")]),v._v(" 优先队列")]),v._v(" "),t("p",[v._v("优先级队列的目标是提供一种抗审查的方式来与 zkSync 进行交互，以防运营商变得恶意或不可用。\nzkSync 2.0 中优先级队列的工作方式与之前版本的 zkSync 中的工作方式非常接近。\n为了全面了解，我们首先介绍优先级队列在 zkSync 1.x 上的工作方式。\n这为 zkSync 2.0 的优先级队列的新设计提供了基本原理。")]),v._v(" "),t("h3",{attrs:{id:"它在-zksync-1-x-中是如何工作的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#它在-zksync-1-x-中是如何工作的"}},[v._v("#")]),v._v(" 它在 zkSync 1.x 中是如何工作的")]),v._v(" "),t("p",[v._v("在之前版本的 zkSync 中，我们只有两个可以从 L1 发送到 zkSync 的操作：")]),v._v(" "),t("ul",[t("li",[t("code",[v._v("Deposit")]),v._v(" 将资金从以太坊连接到 zkSync。")]),v._v(" "),t("li",[t("code",[v._v("FullExit")]),v._v(" 将资金从以太坊返回（这与 zkSync 2.0 中的"),t("code",[v._v("Withdraw")]),v._v(" 基本相同）。")])]),v._v(" "),t("p",[v._v("如果用户想要向 zkSync 存入资金或从 zkSync 提取资金，他们必须向智能合约发送交易请求，然后将其附加到优先交易队列中。 队列有以下规则：")]),v._v(" "),t("ul",[t("li",[v._v("所有交易都按顺序处理。")]),v._v(" "),t("li",[v._v("每个优先操作必须由运营商在提交合同后的“X”天内处理。")])]),v._v(" "),t("p",[v._v("第一条规则由智能合约严格执行。 如果运营商变得恶意或不可用，则可能违反第二条规则。 如果发生这种情况，系统会进入“出走模式”，此时无法处理新的区块，用户可以在没有运营商合作的情况下提取资金。")]),v._v(" "),t("h3",{attrs:{id:"需要做哪些改变"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#需要做哪些改变"}},[v._v("#")]),v._v(" 需要做哪些改变？")]),v._v(" "),t("p",[v._v("上述过程适用于具有一小部分小型操作系统。 zkSync 2.0 支持通用的智能合约计算，因此必须改变一些原则以保持网络的稳定性。")]),v._v(" "),t("p",[v._v("首先，所有交易都需要优先级队列支持。用户可能会将他们的资金锁定在 L2 智能合约上，而不是锁定在他们自己的 L2 账户上。因此，在将资金转移到 L1 之前，他们需要先向 zkSync 网络发送一个 "),t("code",[v._v("Execute")]),v._v(" 交易，以首先从该智能合约中提取资金。")]),v._v(" "),t("p",[v._v("其次，优先队列需要保持抗审查。但是想象一下，如果用户开始发送大量的交易占用了整个区块 ergs 限制，会发生什么？需要有一种方法来防止对系统的垃圾邮件攻击。\n这就是为什么向优先队列提交交易不再是免费的。\n用户需要向运营商支付一定的费用来处理他们的交易。以未经许可的方式计算准确的费用确实很困难。\n因此，一笔交易的费用等于"),t("code",[v._v("txBaseCost * gasPrice")]),v._v("。 "),t("code",[v._v("gasPrice")]),v._v(" 是用户交易的 gas 价格，而 "),t("code",[v._v("txBaseCost")]),v._v(" 是交易的基本成本，取决于其参数（例如 "),t("code",[v._v("ergs_limit")]),v._v(" 用于 "),t("code",[v._v("Execute")]),v._v(" 交易）。")]),v._v(" "),t("p",[v._v("第三，运营商不能承诺在“X”天内处理每笔交易。 同样，这是防止对优先级队列的垃圾邮件攻击所必需的。 我们将此规则更改为以下规则：")]),v._v(" "),t("ul",[t("li",[v._v("运营者必须在优先队列上至少完成“X”的工作量（见下文），否则优先队列应该是空的。")])]),v._v(" "),t("p",[v._v("换句话说，我们要求运营商尽力而为，而不是要求严格的截止日期。 “工作”的衡量标准还有待制定。 最有可能的是优先操作使用的 "),t("code",[v._v("ergs")]),v._v(" 数量。")]),v._v(" "),t("p",[v._v("未来，我们还将添加“优先级”L1->L2 交易的能力，让用户可以加快包含他们的交易，以换取向运营商支付更高的费用。")]),v._v(" "),t("h2",{attrs:{id:"优先模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#优先模式"}},[v._v("#")]),v._v(" 优先模式")]),v._v(" "),t("p",[v._v("如果运营者未能处理所需的 L1 交易，系统将进入 "),t("code",[v._v("Priority mode")]),v._v(". 。 在这种模式下，每个人都可以通过质押代币成为运营商。"),t("code",[v._v("Priority mode")]),v._v(" .的具体细节仍在开发中，将在接近主网启动时进行更详细的描述。")]),v._v(" "),t("p",[v._v("为了降低风险，alpha 主网会启动一种立即停止和升级网络的机制，这与优先模式的目的相矛盾。 优先模式将在后续版本中逐步引入。")]),v._v(" "),t("h2",{attrs:{id:"l2-l1-消息传递"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#l2-l1-消息传递"}},[v._v("#")]),v._v(" L2 -> L1 消息传递")]),v._v(" "),t("p",[t("RouterLink",{attrs:{to:"/dev/developer-guides/bridging/l2-l1.html"}},[v._v("L2 -> L1 通信")]),v._v(" 与 L1 -> L2 通信相比，仅基于传输信息，而不基于 L1 上的交易执行。 它是一个内置功能，由两部分组成：从 L2 发送消息和在 L1 上读取消息。 第一个是作为对 L2 系统智能合约的调用来实现的。 第二个是在 zkSync L1 智能合约上作为 getter 函数实现的。")],1),v._v(" "),t("h3",{attrs:{id:"发送消息"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#发送消息"}},[v._v("#")]),v._v(" 发送消息")]),v._v(" "),t("p",[v._v("从 L2 发送到 L1 的每条消息都包含发送者的地址和消息本身。 消息的长度可以任意大，但是消息越长，发送的成本就越高。 运营商必须包括相应 merkle 根的所有消息（见下一段）。 因此，所有消息都是公开可用的，并且不必依赖运营商来揭示它们。")]),v._v(" "),t("p",[v._v("发送的每条消息都可以在链上读取。 此外，可以证明消息已在特定的 L2 块中发送。 为了使这种证明对用户和运营商都尽可能便宜，我们将每个 L2 块的所有消息存储在 merkle 树中。 因此，任何 L1 智能合约都可以通过提供包含在某个 L2 块中的证明来使用发送的消息。 只能基于运营商发送给 zkSync L1 智能合约的数据生成证明。 也可以通过 "),t("RouterLink",{attrs:{to:"/api/api.html#zksgetl2tol1msgproof"}},[v._v("API")]),v._v(" 获得证明。")],1),v._v(" "),t("h3",{attrs:{id:"l2-l1-消息传递总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#l2-l1-消息传递总结"}},[v._v("#")]),v._v(" L2->L1 消息传递总结")]),v._v(" "),t("ul",[t("li",[v._v("L2 -> L1 通信需要 L2 上的一个交易和 L1 上的一个交易。")]),v._v(" "),t("li",[v._v("消息可以是任意长度。")]),v._v(" "),t("li",[v._v("证明消息包含在 L2 块中所需的所有数据始终可以从以太坊恢复。 但是，最简单的方法是通过 API 向运营商请求证明。")])])])}),[],!1,null,null,null);_.default=r.exports}}]);