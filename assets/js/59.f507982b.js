(window.webpackJsonp=window.webpackJsonp||[]).push([[59],{469:function(e,t,s){"use strict";s.r(t);var o=s(32),a=Object(o.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"fee-mechanism"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#fee-mechanism"}},[e._v("#")]),e._v(" Fee mechanism")]),e._v(" "),s("p",[e._v("zkSync's version of "),s("code",[e._v("gas")]),e._v(" is called "),s("code",[e._v("ergs")]),e._v(" and represents not only the costs of computations but also the cost of publishing data on-chain and affecting storage. Similar to "),s("code",[e._v("gas")]),e._v(", "),s("code",[e._v("ergs")]),e._v(" is an absolute unit. VM operations ("),s("code",[e._v("add")]),e._v(", "),s("code",[e._v("mul")]),e._v(", etc.) will also have their costs measured in "),s("code",[e._v("ergs")]),e._v(", and they may not be equal to each other. The actual table of operation costs in "),s("code",[e._v("ergs")]),e._v(" is yet to be defined.")]),e._v(" "),s("p",[e._v("Since the costs for publishing the calldata on L1 are very volatile, the number of "),s("code",[e._v("ergs")]),e._v(" needed for changing a storage slot is not constant. For each block, the operator defines the following dynamic parameters:")]),e._v(" "),s("ul",[s("li",[s("code",[e._v("ergs_price")]),e._v(" — the table for the current base price in each token. The value of this parameter is used to determine the costs of VM execution in each token.")]),e._v(" "),s("li",[s("code",[e._v("ergs_per_pubdata")]),e._v(" — the price in "),s("code",[e._v("ergs")]),e._v(" for publishing one byte of data to Ethereum.")])]),e._v(" "),s("p",[s("strong",[e._v("Please note that the public data is published only for state diffs.")]),e._v(" If the same storage slot is updated 10 times in the same rollup block, only the final update will be published on Ethereum, thus only charging for public data once.")]),e._v(" "),s("h3",{attrs:{id:"why-do-we-need-a-different-fee-model"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#why-do-we-need-a-different-fee-model"}},[e._v("#")]),e._v(" Why do we need a different fee model?")]),e._v(" "),s("ul",[s("li",[s("strong",[e._v("Why "),s("code",[e._v("ergs")]),e._v(" and not gas?")])])]),e._v(" "),s("p",[e._v("We want to show the clear distinction between our fee model and the Ethereum one. Also, unlike Ethereum, where most of the opcodes have very distinct gas prices, basic zkEVM opcodes will likely have similar "),s("code",[e._v("ergs")]),e._v(" prices. Generally, the execution itself (arithmetic operations, which do not involve storage updates) is very cheap. As in Ethereum, most of the cost is incurred for storage updates.")]),e._v(" "),s("ul",[s("li",[s("strong",[e._v("Why can't we have a constant price for storage value?")])])]),e._v(" "),s("p",[e._v("As part of the zk rollup security model, zkSync periodically publishes state diffs on Ethereum. The price of that is defined by Ethereum gas price and, as stated, is very volatile. This is why the operator can define the new price in "),s("code",[e._v("ergs")]),e._v(" for publishing pubdata for each block. Users can provide a cap on the "),s("code",[e._v("ergs_per_pubdata")]),e._v(" in the "),s("RouterLink",{attrs:{to:"/dev/api/api.html#eip712"}},[e._v("EIP712")]),e._v(" transactions.")],1),e._v(" "),s("h3",{attrs:{id:"what-does-this-mean-to-me"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#what-does-this-mean-to-me"}},[e._v("#")]),e._v(" What does this mean to me?")]),e._v(" "),s("p",[e._v("Despite the differences, the fee model is quite similar to the one of Ethereum; the most costly operation is storage change. One of the advantages of zk rollups over optimistic rollups is that, instead of publishing all the transaction data, zk rollups can publish only state diffs, thus making fewer storage changes.")]),e._v(" "),s("p",[e._v("As already stated, if the same storage slot is updated several times in a single block, only the last update will be published on Ethereum, and the cost of storage change will only be charged once; but it goes beyond simple storage slots. For example, a DEX and a "),s("code",[e._v("PairFactory")]),e._v(" factory for different "),s("code",[e._v("Pair")]),e._v(" pools. The contract bytecode of "),s("code",[e._v("Pair")]),e._v(" needs to be published only when the first instance is deployed. After the code of the "),s("code",[e._v("Pair")]),e._v(" was published once, the subsequent deployments will only involve changing one storage slot -- to set the contract code hash on the newly deployed "),s("code",[e._v("Pair")]),e._v("'s address.")]),e._v(" "),s("p",[e._v("So the tips to make the most out of the zkSync fee system are the following:")]),e._v(" "),s("ul",[s("li",[s("strong",[e._v("Update storage slots as little as possible.")]),e._v(" The cost for execution is a lot smaller than the cost of storage updates.")]),e._v(" "),s("li",[s("strong",[e._v("Reuse as many storage slots as possible.")]),e._v(" Only the state diff is published on Ethereum.")]),e._v(" "),s("li",[s("strong",[e._v("Users should share as many storage slots as possible.")]),e._v(" If 100 users update a storage slot of your contract in a single block, the diff will be published only once. In the future, we will introduce reimbursement for the users, so that the costs for updating shared storage slots are split between the users.")]),e._v(" "),s("li",[s("strong",[e._v("Reuse the contract code if possible.")]),e._v(" On Ethereum, avoiding constructor parameters and putting them into constants reduces some of the gas costs upon contract deployment. On zkSync the opposite is true: deploying the same bytecode for contracts, while changing only constructor parameters can lead to substantial fee savings.")])])])}),[],!1,null,null,null);t.default=a.exports}}]);