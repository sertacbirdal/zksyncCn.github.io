(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{467:function(t,e,v){"use strict";v.r(e);var _=v(32),o=Object(_.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"合约部署"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#合约部署"}},[t._v("#")]),t._v(" 合约部署")]),t._v(" "),v("p",[t._v("为了保持与 L1 相同的安全性，zkSync 运营者必须在以太坊链上发布其部署的每个合约的合约代码。如果有多个使用相同代码部署的合约，那么它只会发布一次。")]),t._v(" "),v("p",[t._v("虽然第一次部署合同可能相对昂贵，但多次部署相同代码的合约的工厂(factory，即可以部署其他合约的合约)，与 L1 相比，可以节省大量的费用。")]),t._v(" "),v("p",[t._v("这些特性让通过 zkEVM 部署智能合约的过程遵循一个主要规则："),v("em",[t._v("在部署合约之前，运营者应该知道合约的代码")]),t._v("。这意味着只能通过 "),v("code",[t._v("EIP712")]),t._v(" 交易的方式部署合约，其中 "),v("code",[t._v("factory_deps")]),t._v(" 字段中包含所提供的字节码。有关 EIP712 交易的更多信息，请通过"),v("RouterLink",{attrs:{to:"/api/api.html#eip712"}},[t._v("这里")]),t._v("了解。")],1),t._v(" "),v("p",[t._v("概要：")]),t._v(" "),v("ul",[v("li",[v("p",[v("strong",[t._v("如何在以太坊上部署合约")])])]),t._v(" "),v("li",[v("p",[t._v("用户将一个交易发送到零地址("),v("code",[t._v("0x000…000")]),t._v(")用于部署合约，交易的 "),v("code",[t._v("data")]),t._v(" 字段等于连接到构造函数参数的合约字节码。")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("如何在 zkSync 上部署合约")])])]),t._v(" "),v("li",[v("p",[t._v("要部署合约，用户调用 "),v("RouterLink",{attrs:{to:"/dev/developer-guides/contracts/system-contracts.html#contractdeployer"}},[t._v("ContractDeployer")]),t._v(" 的 "),v("code",[t._v("create")]),t._v(" 函数并提供要发布的合约的哈希值以及构造函数参数。合约字节码在 EIP712 交易的“factory_deps”字段中提供。如果合约是一个工厂（即它可以部署其他合约），这些合约的字节码也应该包含在 "),v("code",[t._v("factory_deps")]),t._v(" 中。")],1)])]),t._v(" "),v("p",[v("a",{attrs:{href:"../../../api/hardhat"}},[t._v("Hardhat-zksync-deploy")]),t._v(" 插件负责合约部署过程。这里有一个"),v("RouterLink",{attrs:{to:"/api/hardhat/getting-started.html"}},[t._v("关于如何使用它的指南")]),t._v("。")],1),t._v(" "),v("h2",{attrs:{id:"solidity-vyper-支持"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#solidity-vyper-支持"}},[t._v("#")]),t._v(" Solidity/Vyper 支持")]),t._v(" "),v("p",[t._v("将 Solidity 编译成 zkEVM 字节码需要一个特殊的编译器。目前支持 Solidity "),v("code",[t._v(">=0.4.10")]),t._v(" 版本，尽管我们强烈建议使用"),v("code",[t._v("^0.8.0")]),t._v("作为最稳定的版本。Vyper "),v("code",[t._v("^0.3.3")]),t._v("也是支持的。")]),t._v(" "),v("p",[t._v("尽管支持旧版本的 Solidity，但在 zkSync 中，它们有一些限制：")]),t._v(" "),v("ul",[v("li",[t._v("不支持 Contract-local 递归。")]),t._v(" "),v("li",[t._v("不支持内部函数指针。")])]),t._v(" "),v("p",[t._v("如需使用 Solidity 或 Vyper 编译智能合约，可在这里查找相应的"),v("RouterLink",{attrs:{to:"/api/hardhat/plugins.html"}},[t._v(" Hardhat 插件")]),t._v("。")],1),t._v(" "),v("p",[t._v("以太坊加密的原语，如 "),v("code",[t._v("ecrecover")]),t._v("，"),v("code",[t._v("keccak256")]),t._v(" 和 "),v("code",[t._v("sha256")]),t._v(" 支持预编译。您不需要任何操作，因为所有对预编译的调用都是由编译器在底层完成的。")]),t._v(" "),v("h2",{attrs:{id:"create-行为的差异"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#create-行为的差异"}},[t._v("#")]),t._v(" "),v("code",[t._v("CREATE")]),t._v(" 行为的差异")]),t._v(" "),v("p",[t._v("为了便于支持账户抽象，对于每个账户，我们将 nonce 分为两个部分: "),v("em",[t._v("deployment nonce")]),t._v(" 与 "),v("em",[t._v("transaction nonce")]),t._v("。Deployment nonce 是账户使用 "),v("code",[t._v("CREATE")]),t._v(" 操作码部署的智能合约数量，而 transaction nonce 用于对交易的重放攻击保护。")]),t._v(" "),v("p",[t._v("这意味着对于智能合约来说，zkSync 上的 nonce 与以太坊上的行为相同，但对于 EOAs 来说，计算部署合约的地址就不那么简单了。在以太坊上，它可以安全地计算为 "),v("code",[t._v("hash(RLP[address, nonce])")]),t._v("，而在 zkSync 上，建议等待合约部署完成，并使用新部署的合约地址抓取活动。这些都是由 SDK 在底层完成的。\n要获得一个确定的地址，您应该使用 "),v("code",[t._v("create2")]),t._v(" 来创建合约。它也可以用于 EOAs，但在 SDK 中尚不可用。")]),t._v(" "),v("h2",{attrs:{id:"关于-factory-deps-的注意事项"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#关于-factory-deps-的注意事项"}},[t._v("#")]),t._v(" 关于 "),v("code",[t._v("factory deps")]),t._v(" 的注意事项")]),t._v(" "),v("p",[t._v("Under the hood, zkSync stores not bytecodes of contracts, but "),v("a",{attrs:{href:"#format-of-bytecode-hash"}},[t._v("specially formatted")]),t._v(" hashes of their bytecodes. You can see that even the "),v("RouterLink",{attrs:{to:"/dev/developer-guides/contracts/system-contracts.html#contractdeployer"}},[t._v("ContractDeployer")]),t._v(" system contract accepts the bytecode hash of the deployed contract and not its bytecode. However, for contract deployment to succeed, the operator needs to know the bytecode. Exactly for this reason the "),v("code",[t._v("factory_deps")]),t._v(' (i.e. factory dependencies) field for transactions is used: it contains the bytecodes that should be known to the operator for this transaction to succeed. Once the transaction succeeds, these bytecodes will be published on L1 and will be considered "known" to the operator forever.')],1),t._v(" "),v("p",[t._v("一些用法的例子:\n最明显的一个例子是，在部署合约时，需要在 "),v("code",[t._v("factory deps")]),t._v(" 字段中提供它的代码。")]),t._v(" "),v("ul",[v("li",[t._v("在 zkSync 上，工厂不存储它们依赖项的字节码，即它们可以部署的合约。它们只存储哈希值。这就是为什么您需要在 "),v("code",[t._v("factory_deps")]),t._v(" 字段中包含"),v("em",[t._v("所有")]),t._v("依赖的字节码。")])]),t._v(" "),v("p",[t._v("这两个例子已经通过我们的 "),v("RouterLink",{attrs:{to:"/api/hardhat/plugins.html"}},[t._v(" Hardhat 插件")]),t._v("在底层无缝完成。")],1),t._v(" "),v("p",[t._v("请注意，factory_deps 不一定必须以某种方式由交易调用。这些只是标记，表明这些字节码应该和这个交易一起发布到 L1 上。如果您的合约包含许多不同的工厂依赖项并且它们不适合单个 L1 区块，您可以在多个交易之间拆分工厂依赖项的列表。")]),t._v(" "),v("p",[t._v("例如，如果您想部署合约 "),v("code",[t._v("A")]),t._v("，它也可以部署合约 "),v("code",[t._v("B")]),t._v(" 和 "),v("code",[t._v("C")]),t._v("。这意味着您将有三个工厂依赖项来部署交易："),v("code",[t._v("A")]),t._v("、"),v("code",[t._v("B")]),t._v(" 和 "),v("code",[t._v("C")]),t._v("。如果发布它们所需的 pubdata 太大，无法放入同一个区块中，您可以发送一个只包含工厂依赖项 "),v("code",[t._v("A")]),t._v(" 和 "),v("code",[t._v("B")]),t._v(" 的虚拟交易(假设它们的总长度足够小)，并使用第二个交易进行实际部署，同时提供合约 "),v("code",[t._v("C")]),t._v(" 的字节码作为工厂依赖项。注意，如果某个合约"),v("em",[t._v("本身")]),t._v("大于每个区块允许的限制，则必须将该合约拆分为更小的合约。")]),t._v(" "),v("h3",{attrs:{id:"l1-l2-通信"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#l1-l2-通信"}},[t._v("#")]),t._v(" L1->L2 通信")]),t._v(" "),v("p",[t._v("提交 L1->L2 交易的"),v("a",{attrs:{href:"https://github.com/matter-labs/v2-testnet-contracts/blob/d4a2869ab6feadb396f357e55aa41d137adc0ab0/l1/contracts/zksync/interfaces/IMailbox.sol#L76",target:"_blank",rel:"noopener noreferrer"}},[t._v("接口"),v("OutboundLink")],1),t._v("接受这个特定交易所需的所有工厂依赖项的列表。处理它们的逻辑与处理 L2 交易的逻辑相同。唯一的区别是，由于用户已经在 L1 上发布了字节码的完整映像，所以不需要在 L1 上再次发布这些字节码。")]),t._v(" "),v("h3",{attrs:{id:"字节码哈希值的格式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#字节码哈希值的格式"}},[t._v("#")]),t._v(" 字节码哈希值的格式")]),t._v(" "),v("p",[t._v("每个 zkEVM 字节码必须符合以下格式:")]),t._v(" "),v("ul",[v("li",[t._v("其长度必须能被 32 整除。")]),t._v(" "),v("li",[t._v("它的长度（32 字节块）应该是奇数。换句话说，"),v("code",[t._v("bytecodeLength % 64 == 32")]),t._v("。")]),t._v(" "),v("li",[t._v("它不能长于 "),v("code",[t._v("2^16")]),t._v("32 字节的字，也就是 "),v("code",[t._v("2^21")]),t._v(" 字节。")])]),t._v(" "),v("p",[t._v("zkSync 合约字节码的 32 字节哈希值计算方法如下:")]),t._v(" "),v("ul",[v("li",[t._v("前两个字节表示字节码哈希值格式的版本，目前等于 "),v("code",[t._v("[1,0]")]),t._v("。")]),t._v(" "),v("li",[t._v("第二个 2 字节表示字节码的长度，以 32 字节为单位。")]),t._v(" "),v("li",[t._v("其余 28 字节（即 28 个低位大端序字节）等于 "),v("code",[t._v("sha256")]),t._v(" 合约字节码哈希值的最后 28 个字节。")])])])}),[],!1,null,null,null);e.default=o.exports}}]);