(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{427:function(t,e,a){"use strict";a.r(e);var s=a(32),r=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"web3-api"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#web3-api"}},[t._v("#")]),t._v(" Web3 API")]),t._v(" "),a("p",[t._v("zkSync 2.0 fully supports the standard "),a("a",{attrs:{href:"https://ethereum.org/en/developers/docs/apis/json-rpc/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Ethereum JSON-RPC API"),a("OutboundLink")],1),t._v(" and adds some L2-specific features.")]),t._v(" "),a("p",[t._v("As long as the code does not involve deploying new smart contracts (they can only be deployed using EIP712 transactions, more on that "),a("a",{attrs:{href:"#eip712"}},[t._v("below")]),t._v("), "),a("em",[t._v("no changes to the codebase are needed.")])]),t._v(" "),a("p",[t._v("It is possible to continue using the SDK that is currently in use. Users will continue paying fees in ETH, and the UX will be identical to the one on Ethereum.")]),t._v(" "),a("p",[t._v("However, zkSync has its specifics, which this section describes.")]),t._v(" "),a("h2",{attrs:{id:"eip712"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#eip712"}},[t._v("#")]),t._v(" EIP712")]),t._v(" "),a("p",[t._v("To specify additional fields, like the custom signature for custom accounts or to choose the paymaster, EIP712 transactions should be used. These transactions have the same fields as standard Ethereum transactions, but they also have fields that contain additional L2-specific data ("),a("code",[t._v("paymaster")]),t._v(", etc).")]),t._v(" "),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"ergsPerPubdata"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"1212"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"customSignature"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0x..."')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"paymasterParams"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"paymaster"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0x..."')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"paymasterInput"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0x..."')]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"factory_deps"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0x..."')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n")])])]),a("ul",[a("li",[a("code",[t._v("ergsPerPubdata")]),t._v(": is a field that describes the maximal amount of ergs the user is willing to pay for a single byte of pubdata.")]),t._v(" "),a("li",[a("code",[t._v("customSignature")]),t._v(" is a field with a custom signature, in case the signer's account is not EOA.")]),t._v(" "),a("li",[a("code",[t._v("paymasterParams")]),t._v(" is a field with parameters for configuring the custom paymaster for the transaction. The address of the paymaster and the encoded input to call it are in the paymaster parameters.")]),t._v(" "),a("li",[a("code",[t._v("factory_deps")]),t._v(" is a field that should be a non-empty array of "),a("code",[t._v("bytes")]),t._v(" for deployment transactions. It should contain the bytecode of the contract being deployed. If the contract being deployed is a factory contract, i.e. it can deploy other contracts, the array should also contain the bytecodes of the contracts which can be deployed by it.")])]),t._v(" "),a("p",[t._v("To let the server recognize EIP712 transactions, the "),a("code",[t._v("transaction_type")]),t._v(" field is equal to "),a("code",[t._v("113")]),t._v(" (unfortunately the number "),a("code",[t._v("712")]),t._v(" can not be used as the "),a("code",[t._v("transaction_type")]),t._v(" since the type has to be one byte long).")]),t._v(" "),a("p",[t._v("Instead of signing the RLP-encoded transaction, the user signs the following typed EIP712 structure:")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("Field name")]),t._v(" "),a("th",[t._v("Type")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("txType")]),t._v(" "),a("td",[a("code",[t._v("uint256")])])]),t._v(" "),a("tr",[a("td",[t._v("from")]),t._v(" "),a("td",[a("code",[t._v("uint256")])])]),t._v(" "),a("tr",[a("td",[t._v("to")]),t._v(" "),a("td",[a("code",[t._v("uint256")])])]),t._v(" "),a("tr",[a("td",[t._v("ergsLimit")]),t._v(" "),a("td",[a("code",[t._v("uint256")])])]),t._v(" "),a("tr",[a("td",[t._v("ergsPerPubdataByteLimit")]),t._v(" "),a("td",[a("code",[t._v("uint256")])])]),t._v(" "),a("tr",[a("td",[t._v("maxFeePerErg")]),t._v(" "),a("td",[a("code",[t._v("uint256")])])]),t._v(" "),a("tr",[a("td",[t._v("maxPriorityFeePerErg")]),t._v(" "),a("td",[a("code",[t._v("uint256")])])]),t._v(" "),a("tr",[a("td",[t._v("paymaster")]),t._v(" "),a("td",[a("code",[t._v("uint256")])])]),t._v(" "),a("tr",[a("td",[t._v("nonce")]),t._v(" "),a("td",[a("code",[t._v("uint256")])])]),t._v(" "),a("tr",[a("td",[t._v("value")]),t._v(" "),a("td",[a("code",[t._v("uint256")])])]),t._v(" "),a("tr",[a("td",[t._v("data")]),t._v(" "),a("td",[a("code",[t._v("bytes")])])]),t._v(" "),a("tr",[a("td",[t._v("factoryDeps")]),t._v(" "),a("td",[a("code",[t._v("bytes32[]")])])]),t._v(" "),a("tr",[a("td",[t._v("paymasterInput")]),t._v(" "),a("td",[a("code",[t._v("bytes")])])])])]),t._v(" "),a("p",[t._v("These fields are conveniently handled by our "),a("RouterLink",{attrs:{to:"/api/js/features.html"}},[t._v("SDK")]),t._v(".")],1),t._v(" "),a("h2",{attrs:{id:"zksync-specific-json-rpc-methods"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#zksync-specific-json-rpc-methods"}},[t._v("#")]),t._v(" zkSync-specific JSON-RPC methods")]),t._v(" "),a("p",[t._v("All zkSync-specific methods are located in the "),a("code",[t._v("zks_")]),t._v(" namespace. The API may also provide methods other than those provided here. These methods are to be used internally by the team and are very unstable.")]),t._v(" "),a("div",{staticClass:"custom-block warning"},[a("p",{staticClass:"custom-block-title"},[t._v("WARNING")]),t._v(" "),a("p",[t._v("Please note that Metamask does not support zks_ namespace's methods, we are working to support it in the future, alternatively, you can use the "),a("code",[t._v("Provider")]),t._v(" class with the testnet RPC instead of relying on Metamask's injected provider.")])]),t._v(" "),a("h3",{attrs:{id:"zks-getmaincontract"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#zks-getmaincontract"}},[t._v("#")]),t._v(" "),a("code",[t._v("zks_getMainContract")])]),t._v(" "),a("p",[t._v("Returns the address of the zkSync contract.")]),t._v(" "),a("h3",{attrs:{id:"input-parameters"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#input-parameters"}},[t._v("#")]),t._v(" Input parameters")]),t._v(" "),a("p",[t._v("None.")]),t._v(" "),a("h3",{attrs:{id:"output-format"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#output-format"}},[t._v("#")]),t._v(" Output format")]),t._v(" "),a("p",[a("code",[t._v('"0xaBEA9132b05A70803a4E85094fD0e1800777fBEF"')])]),t._v(" "),a("h3",{attrs:{id:"zks-l1chainid"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#zks-l1chainid"}},[t._v("#")]),t._v(" "),a("code",[t._v("zks_L1ChainId")])]),t._v(" "),a("p",[t._v("Returns the chain id of the underlying L1.")]),t._v(" "),a("h3",{attrs:{id:"input-parameters-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#input-parameters-2"}},[t._v("#")]),t._v(" Input parameters")]),t._v(" "),a("p",[t._v("None.")]),t._v(" "),a("h3",{attrs:{id:"output-format-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#output-format-2"}},[t._v("#")]),t._v(" Output format")]),t._v(" "),a("p",[a("code",[t._v("12")])]),t._v(" "),a("h3",{attrs:{id:"zks-getconfirmedtokens"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#zks-getconfirmedtokens"}},[t._v("#")]),t._v(" "),a("code",[t._v("zks_getConfirmedTokens")])]),t._v(" "),a("p",[t._v("Given "),a("code",[t._v("from")]),t._v(" and "),a("code",[t._v("limit")]),t._v(" return information about the confirmed tokens with IDs in the interval "),a("code",[t._v("[from..from+limit-1]")]),t._v('. "Confirmed" is the wrong word here, since a confirmed token has already been bridged through the default zkSync bridge.')]),t._v(" "),a("p",[t._v("The tokens are returned in alphabetical order by their symbols, so a token's id is just its place in an array of tokens that has been sorted by symbols.")]),t._v(" "),a("h3",{attrs:{id:"input-parameters-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#input-parameters-3"}},[t._v("#")]),t._v(" Input parameters")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("Parameter")]),t._v(" "),a("th",[t._v("Type")]),t._v(" "),a("th",[t._v("Description")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("from")]),t._v(" "),a("td",[a("code",[t._v("uint32")])]),t._v(" "),a("td",[t._v("The token id from which to start returning the information about the tokens.")])]),t._v(" "),a("tr",[a("td",[t._v("limit")]),t._v(" "),a("td",[a("code",[t._v("uint8")])]),t._v(" "),a("td",[t._v("The number of tokens to be returned from the API.")])])])]),t._v(" "),a("h3",{attrs:{id:"output-format-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#output-format-3"}},[t._v("#")]),t._v(" Output format")]),t._v(" "),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"address"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"decimals"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("18")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"name"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"ETH"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"symbol"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"ETH"')]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"address"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0xd2255612f9b045e9c81244bb874abb413ca139a3"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"decimals"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("18")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"name"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"TrueUSD"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"symbol"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"TUSD"')]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"address"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0xd35cceead182dcee0f148ebac9447da2c4d449c4"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"decimals"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("6")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"name"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"USD Coin (goerli)"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"symbol"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"USDC"')]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n")])])]),a("h3",{attrs:{id:"zks-getl2tol1logproof"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#zks-getl2tol1logproof"}},[t._v("#")]),t._v(" "),a("code",[t._v("zks_getL2ToL1LogProof")])]),t._v(" "),a("p",[t._v("Given a transaction hash, and an index of the L2 to L1 log produced within the transaction, it returns the proof for the corresponding L2 to L1 log.")]),t._v(" "),a("p",[t._v("The index of the log that can be obtained from the transaction receipt (it includes a list of every log produced by the transaction).")]),t._v(" "),a("h3",{attrs:{id:"input-parameters-4"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#input-parameters-4"}},[t._v("#")]),t._v(" Input parameters")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("Parameter")]),t._v(" "),a("th",[t._v("Type")]),t._v(" "),a("th",[t._v("Description")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("tx_hash")]),t._v(" "),a("td",[a("code",[t._v("bytes32")])]),t._v(" "),a("td",[t._v("Hash of the L2 transaction the L2 to L1 log was produced within.")])]),t._v(" "),a("tr",[a("td",[t._v("l2_to_l1_log_index")]),t._v(" "),a("td",[a("code",[t._v("undefined")]),t._v(" | "),a("code",[t._v("number")])]),t._v(" "),a("td",[t._v("The Index of the L2 to L1 log in the transaction.")])])])]),t._v(" "),a("h3",{attrs:{id:"output-format-4"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#output-format-4"}},[t._v("#")]),t._v(" Output format")]),t._v(" "),a("p",[t._v("If there was no such message, the returned value is "),a("code",[t._v("null")]),t._v(".")]),t._v(" "),a("p",[t._v("Otherwise, the object of the following format is returned:")]),t._v(" "),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"id"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"proof"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0x66687aadf862bd776c8fc18b8e9f8e20089714856ee233b3902a591d0d5f2925"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0x2eeb74a6177f588d80c0c752b99556902ddf9682d0b906f5aa2adbaf8466a4e9"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0x1223349a40d2ee10bd1bebb5889ef8018c8bc13359ed94b387810af96c6e4268"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0x5b82b695a7ac2668e188b75f7d4fa79faa504117d1fdfcbe8a46915c1a8a5191"')]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"root"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0x6a420705824f0a3a7e541994bc15e14e6a8991cd4e4b2d35c66f6e7647760d97"')]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("The "),a("code",[t._v("id")]),t._v(" is the position of the leaf in the Merkle tree of L2->L1 messages for the block. The "),a("code",[t._v("proof")]),t._v(" is the Merkle proof for the message, while the "),a("code",[t._v("root")]),t._v(" is the root of the Merkle tree of L2->L1 messages. Please note, that the Merkle tree uses "),a("em",[t._v("sha256")]),t._v(" for the trees.")]),t._v(" "),a("p",[t._v("You do not need to care about the intrinsics, since the returned "),a("code",[t._v("id")]),t._v(" and "),a("code",[t._v("proof")]),t._v(" can be used right away for interacting with the zkSync smart contract.")]),t._v(" "),a("p",[t._v("A nice example of using this endpoint via our SDK can be found "),a("RouterLink",{attrs:{to:"/dev/developer-guides/bridging/l2-l1.html"}},[t._v("here")]),t._v(".")],1),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),a("p",[t._v("The list of L2 to L1 logs produced by the transaction, which is included in the receipts, is a combination of logs produced by L1Messenger contract or other system contracts/bootloader.")]),t._v(" "),a("p",[t._v("There is a log produced by the bootloader for every L1 originated transaction that shows if the transaction has succeeded.")])]),t._v(" "),a("h3",{attrs:{id:"zks-getl2tol1msgproof"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#zks-getl2tol1msgproof"}},[t._v("#")]),t._v(" "),a("code",[t._v("zks_getL2ToL1MsgProof")])]),t._v(" "),a("p",[t._v("Given a block, a sender, a message, and an optional message log index in the block containing the L1->L2 message, it returns the proof for the message sent via the L1Messenger system contract.")]),t._v(" "),a("h3",{attrs:{id:"input-parameters-5"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#input-parameters-5"}},[t._v("#")]),t._v(" Input parameters")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("Parameter")]),t._v(" "),a("th",[t._v("Type")]),t._v(" "),a("th",[t._v("Description")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("block")]),t._v(" "),a("td",[a("code",[t._v("uint32")])]),t._v(" "),a("td",[t._v("The number of the block where the message was emitted.")])]),t._v(" "),a("tr",[a("td",[t._v("sender")]),t._v(" "),a("td",[a("code",[t._v("address")])]),t._v(" "),a("td",[t._v("The sender of the message (i.e. the account that called the L1Messenger system contract).")])]),t._v(" "),a("tr",[a("td",[t._v("msg")]),t._v(" "),a("td",[a("code",[t._v("bytes32")])]),t._v(" "),a("td",[t._v("The keccak256 hash of the sent message.")])]),t._v(" "),a("tr",[a("td",[t._v("l2_log_position")]),t._v(" "),a("td",[a("code",[t._v("uint256")]),t._v(" | "),a("code",[t._v("null")])]),t._v(" "),a("td",[t._v("The index in the block of the event that was emitted by the "),a("RouterLink",{attrs:{to:"/dev/developer-guides/contracts/system-contracts.html#il1messenger"}},[t._v("L1Messenger")]),t._v(" when submitting this message. If it is ommitted, the proof for the first message with such content will be returned.")],1)])])]),t._v(" "),a("h3",{attrs:{id:"output-format-5"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#output-format-5"}},[t._v("#")]),t._v(" Output format")]),t._v(" "),a("p",[t._v("The same as in "),a("a",{attrs:{href:"#output-format-4"}},[t._v("zks_getL2ToL1LogProof")]),t._v(".")]),t._v(" "),a("div",{staticClass:"custom-block warning"},[a("p",{staticClass:"custom-block-title"},[t._v("WARNING")]),t._v(" "),a("p",[a("code",[t._v("zks_getL2ToL1MsgProof")]),t._v(" endpoint will be deprecated because proofs for L2 to L1 messages can also be fetched from "),a("code",[t._v("zks_getL2ToL1LogProof")]),t._v(".")])]),t._v(" "),a("h3",{attrs:{id:"zks-getbridgecontracts"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#zks-getbridgecontracts"}},[t._v("#")]),t._v(" "),a("code",[t._v("zks_getBridgeContracts")])]),t._v(" "),a("p",[t._v("Returns L1/L2 addresses of default bridges.")]),t._v(" "),a("h3",{attrs:{id:"input-parameters-6"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#input-parameters-6"}},[t._v("#")]),t._v(" Input parameters")]),t._v(" "),a("p",[t._v("None.")]),t._v(" "),a("h3",{attrs:{id:"output-format-6"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#output-format-6"}},[t._v("#")]),t._v(" Output format")]),t._v(" "),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"l1Erc20DefaultBridge"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0x7786255495348c08f82c09c82352019fade3bf29"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"l1EthDefaultBridge"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0xcbebcd41ceabbc85da9bb67527f58d69ad4dfff5"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"l2Erc20DefaultBridge"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0x92131f10c54f9b251a5deaf3c05815f7659bbe02"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"l2EthDefaultBridge"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0x2c5d8a991f399089f728f1ae40bd0b11acd0fb62"')]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("h3",{attrs:{id:"zks-gettestnetpaymaster"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#zks-gettestnetpaymaster"}},[t._v("#")]),t._v(" "),a("code",[t._v("zks_getTestnetPaymaster")])]),t._v(" "),a("p",[t._v("Returns the address of the "),a("RouterLink",{attrs:{to:"/dev/developer-guides/aa.html#testnet-paymaster"}},[t._v("testnet paymaster")]),t._v(": the paymaster that is available on testnets and enables paying fees in ERC-20 compatible tokens.")],1),t._v(" "),a("h3",{attrs:{id:"input-parameters-7"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#input-parameters-7"}},[t._v("#")]),t._v(" Input parameters")]),t._v(" "),a("p",[t._v("None.")]),t._v(" "),a("h3",{attrs:{id:"output-format-7"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#output-format-7"}},[t._v("#")]),t._v(" Output format")]),t._v(" "),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0x7786255495348c08f82c09c82352019fade3bf29"')]),t._v("\n")])])]),t._v(" "),a("h2",{attrs:{id:"pubsub-api"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pubsub-api"}},[t._v("#")]),t._v(" PubSub API")]),t._v(" "),a("p",[t._v("zkSync is fully compatible with "),a("a",{attrs:{href:"https://geth.ethereum.org/docs/rpc/pubsub",target:"_blank",rel:"noopener noreferrer"}},[t._v("Geth's pubsub API"),a("OutboundLink")],1),t._v(", except for the "),a("code",[t._v("syncing")]),t._v(" subscription, as it doesn't have meaning for the zkSync network since technically our nodes are always synced.")]),t._v(" "),a("p",[t._v("The WebSocket URL is "),a("code",[t._v("wss://zksync2-testnet.zksync.dev/ws")]),t._v(".")])])}),[],!1,null,null,null);e.default=r.exports}}]);