import{_ as i,W as l,X as d,Z as e,$ as t,a0 as n,a2 as o,Y as r,D as c}from"./framework-674379d2.js";const h={},_=e("h1",{id:"交易",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#交易","aria-hidden":"true"},"#"),t(" 交易")],-1),p=e("p",null,"以太坊的交易是由外部拥有的账户（由用户而非代码拥有的账户）加密签署的指令。这些指令被存储在区块链中，并添加到一个区块中。 当一个交易启动时，以太坊虚拟机（EVM）的状态会发生变化。一个交易可以是任何东西，从发送乙醚到另一个账户到调用智能合约的功能。",-1),u=e("h2",{id:"前提是",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#前提是","aria-hidden":"true"},"#"),t(" 前提是")],-1),f={href:"https://ethereum.org/en/developers/docs/accounts/",target:"_blank",rel:"noopener noreferrer"},y=r('<h2 id="交易如何运作" tabindex="-1"><a class="header-anchor" href="#交易如何运作" aria-hidden="true">#</a> 交易如何运作</h2><p>当用户在以太坊上发起交易时，一些特定的数据会被创建。</p><ul><li>收件人。收件人是接收交易的账户地址。接收者可以是一个合约账户或外部拥有的账户。每笔交易都是针对一个特定的收件人的。</li><li>Nonce：这个字段显示的是基于账户计数器的最新交易，该计数器保持着对其交易数量的跟踪。网络使用交易nonce来确保交易以正确的顺序完成。</li><li>汽油价格。大多数交易必须从交易的作者那里支付一笔费用。这个费用是按单位气体计算的。这个单位是Wei，一个较小的乙醚单位。</li><li>气体限额：交易作者指定交易使用的气体单位数量。这是可消耗的气体总量。</li><li>价值。发送方账户希望传输给接收方的Wei或Ether的数量，由价值表示。</li><li>数据。如果交易接收方是一个智能合约，那么数据就包含了合约功能的执行信息。这包括具有不同长度的数据。</li><li>签名。签名表明谁发送了通信。当一个外部拥有的账户用其私钥确认并签署交易时，签名就会产生。</li></ul><h3 id="交易类型" tabindex="-1"><a class="header-anchor" href="#交易类型" aria-hidden="true">#</a> 交易类型</h3><ul><li>简单或资产转移。这指的是以乙醚形式从一个账户到另一个账户的常规代币转移。</li></ul><p>为了部署一个合同，用户调用ContractDeployer的<code>create</code>函数，并提供要发布的合同的哈希值以及构造器参数。合同字节码本身是在EIP712事务的factory_deps字段中提供的。如果合同是一个工厂（即它可以部署其他合同），这些合同的字节码也应该包括在 factory_deps 中。</p>',6),k=e("li",null,[t("以太坊。当用户向零地址"),e("code",null,"(0x000...000)"),t("发送一个交易，交易的"),e("code",null,"data"),t("字段等于与构造器参数相连接的合同字节码时，合同部署就发生了。")],-1),m=e("code",null,"create",-1),x=e("code",null,"factory_deps",-1),S=e("code",null,"factory_deps",-1),E={class:"hint-container tip"},v=e("p",{class:"hint-container-title"},"Tips",-1),z=e("p",null,'zkSync支持Ethereum的 "旧"（EIP2718之前）交易类型，即EIP1559交易类型，以及其EIP712交易。这种类型的交易可用于访问zkSync的特定功能，如账户抽象。此外，智能合约只能用这种交易来部署。',-1),g=r('<h3 id="什么时候交易被认为是最终的" tabindex="-1"><a class="header-anchor" href="#什么时候交易被认为是最终的" aria-hidden="true">#</a> 什么时候交易被认为是最终的？</h3><p><strong>交易最终性</strong>是指在区块链网络背景下，交易不能被逆转、改变或变异的承诺。</p><p>在股权证明下，以太坊交易在正常情况下平均在2.5个纪元（16分钟）内最终完成：恢复该交易将花费以太坊总供应量的1/3。</p><p>一旦一个区块在zk卷中被填充和密封，它的状态就会被提交到以太坊主链上。然后开始证明阶段，并为每个区块交易构建一个SNARK有效性证明。一旦完成，SNARK被发送到L1智能合约上进行验证，交易状态在验证后成为最终状态。</p><p>从zkSync的角度来看，当交易（SNARK验证）被L1执行时，_finality_就发生了。在这一点上，保证与同一L1区块内的任何其他L1交易相同；在初始区块被处理后发出的L1区块越多，这个交易被推翻的可能性就越小。</p><p>当用户传输交易时，zkSync目前正在等待整个区块被填充，这意味着最终时间可能会更长，这取决于通过zkSync发送的交易量。随着吞吐量的增加，最终时间将减少。</p><h3 id="运营商到底是什么" tabindex="-1"><a class="header-anchor" href="#运营商到底是什么" aria-hidden="true">#</a> 运营商到底是什么？</h3><p><strong>操作者</strong>是执行基本的ZK滚动功能的角色。他们负责生产区块，包装交易，进行计算，并将数据提交给以太坊主链进行验证。</p>',8);function L(b,N){const s=c("ExternalLinkIcon"),a=c("RouterLink");return l(),d("div",null,[_,p,u,e("p",null,[t("我们建议你先阅读"),e("a",f,[t("账户"),n(s)]),t("以了解本页面。")]),y,e("ul",null,[e("li",null,[t("合约部署事务。zkSync上的合约部署与Ethereum有很大不同。 "),e("ul",null,[k,e("li",null,[t("zkSync。要在zkSync上部署合同，用户调用"),n(a,{to:"/dev/developer-guides/transactions/.../system-contracts.html#contractdeployer"},{default:o(()=>[t("ContractDeployer")]),_:1}),t("的"),m,t("函数，并提供要发布的合同的哈希值以及构造函数参数。 合同字节码本身是在EIP712事务的"),x,t("字段中提供的。 如果合同是一个工厂（即它可以部署其他合同），这些合同的字节码也应该包括在"),S,t("中。 阅读更多关于"),n(a,{to:"/dev/developer-guides/transactions/.../.../building-on-zksync/contracts/contracts.html"},{default:o(()=>[t("合同部署")]),_:1}),t("。")])])])]),e("div",E,[v,z,e("p",null,[t("利用zkSync的SDK没有必要了解交易格式，但如果你有兴趣，你可以了解更多关于它的信息"),n(a,{to:"/dev/developer-guides/transactions/.../.../.../api/api.html#eip712"},{default:o(()=>[t("这里")]),_:1}),t("。")])]),g])}const K=i(h,[["render",L],["__file","transactions.html.vue"]]);export{K as default};
