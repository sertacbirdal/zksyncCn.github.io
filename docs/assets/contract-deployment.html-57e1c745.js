import{_ as a,W as s,X as r,Z as t,a0 as o,a2 as c,$ as e,Y as i,D as d}from"./framework-674379d2.js";const h={},_=t("h1",{id:"合约部署",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#合约部署","aria-hidden":"true"},"#"),e(" 合约部署")],-1),u=t("p",null,"为了保持与L1相同的安全性，zkSync运营商必须在以太坊链上发布它所部署的每个合约的代码。然而，如果有多个合同部署了相同的代码，它将只在以太坊上发布一次。虽然第一次部署合约可能相对昂贵，但多次部署相同代码的合约的工厂，与L1相比，可以有很大的节省。",-1),p=t("p",null,[e("所有这些具体细节使zkEVM上部署智能合约的过程符合主要规则。"),t("em",null,"操作者在部署合约之前应该知道合约的代码"),e("。这意味着，部署合约只能通过"),t("code",null,"EIP712"),e("交易进行，"),t("code",null,"factory_deps"),e("字段包含提供的字节码。")],-1),y=t("h2",{id:"以太坊-zksync的差异",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#以太坊-zksync的差异","aria-hidden":"true"},"#"),e(" 以太坊/zkSync的差异")],-1),f=t("p",null,[t("strong",null,"在以太坊上部署合约是如何进行的。")],-1),k=t("p",null,"为了在以太坊上部署一个合约，用户需要向零地址（0x000...000）发送一个交易，交易的数据字段等于合约字节码与构造函数参数的串联。",-1),m=t("p",null,[t("strong",null,"在zkSync上部署合约的方式。")],-1),z=t("code",null,"create",-1),b=t("code",null,"factory_deps",-1),g=t("code",null,"factory_deps",-1),L=t("p",null,[e("我们推荐使用"),t("a",{href:"./././api/hardhat"},"hardhat-zksync-deploy"),e("插件，以简化部署过程。它提供了类和方法来处理所有的部署要求，比如生成"),t("a",{href:"#format-of-bytecode-hash"},"合同的字节码哈希"),e("。")],-1),v=t("h3",{id:"关于-工厂部署-的说明",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#关于-工厂部署-的说明","aria-hidden":"true"},"#"),e(' 关于 "工厂部署 "的说明')],-1),E=t("p",null,[e("一个好的问题是，验证器如何知道执行代码的字节码哈希值的预象？ 这里就出现了工厂依赖的概念("),t("code",null,"factory_deps"),e("简称)! 工厂依赖是一个字节码哈希值的列表，其预像在L1上显示（数据总是可用的）。")],-1),x=t("a",{href:"#format-of-bytecode-hash"},"特别格式化的字节码哈希",-1),S=t("code",null,"factory_deps",-1),C=t("p",null,"一些用法的例子是。",-1),D=t("ul",null,[t("li",null,[e("显而易见的是，当你部署一个合同时，你需要在"),t("code",null,"factory_deps"),e("字段中提供其代码。")]),t("li",null,'在zkSync上，工厂（即可以部署其他合同的合同）并不存储其依赖的字节码，即他们可以部署的合同。它们只存储它们的哈希值。这就是为什么你需要在 "factory_deps "字段中包含所有依赖的字节码。')],-1),A=i('<p>请注意，工厂部署不一定要以任何方式被事务使用。这些只是标记，表明这些字节码应该和这个事务一起发布在L1上。如果你的合同包含很多不同的工厂依赖，而且它们不适合放在一个L1块中，你可以在多个事务之间分割工厂依赖的列表。</p><p>例如，假设你想部署合同<code>A</code>，它也可以部署合同<code>B</code>和<code>C</code>。这意味着你的部署事务将有三个工厂依赖关系：<code>A</code>、<code>B</code>和<code>C</code>。如果发布所有合约所需的pubdata太大，无法装入一个区块，你可以发送一个只有工厂依赖的<code>A</code>和<code>B</code>的虚拟事务（假设它们的总长度足够小），用第二个事务进行实际部署，同时提供合约<code>C</code>的字节码作为它的工厂依赖。请注意，如果某个合同_本身大于每个区块允许的限制，这个合同就必须被分割成更小的合同。</p><h3 id="字节码哈希的格式" tabindex="-1"><a class="header-anchor" href="#字节码哈希的格式" aria-hidden="true">#</a> 字节码哈希的格式</h3><p>每个zkEVM字节码必须遵守以下格式。</p><ul><li>其长度必须能被32整除。</li><li>它的字长(32字节的块)应该是奇数。换句话说，<code>bytecodeLength % 64 == 32</code>。</li><li>它不能长于<code>2^16</code>个32字节的字，即<code>2^21</code>个字节。</li></ul><p>zkSync合约的字节码的32字节哈希值是按照以下方式计算的。</p><ul><li>前两个字节表示字节码哈希格式的版本，目前等于<code>[1,0]</code>。</li><li>后2个字节表示字节码的长度，以32字节为单位。</li><li>其余的28个字节(即28个低大数字节)等于合同字节码的<code>sha256</code>哈希值的最后28个字节。</li></ul><h3 id="create行为的差异" tabindex="-1"><a class="header-anchor" href="#create行为的差异" aria-hidden="true">#</a> <code>CREATE</code>行为的差异</h3>',8),B=t("code",null,"hash(RLP[address, nonce])",-1),I=t("code",null,"ContractDeployed",-1),V=t("code",null,"create2",-1),R=t("h2",{id:"从l1部署合约",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#从l1部署合约","aria-hidden":"true"},"#"),e(" 从L1部署合约")],-1),N=t("p",null,"在zkSync Era上部署合同也可以通过L1-L2通信实现。",-1),P={href:"https://github.com/matter-labs/v2-testnet-contracts/blob/main/l1/contracts/zksync/interfaces/IMailbox.sol#L78",target:"_blank",rel:"noopener noreferrer"};function M(T,K){const n=d("RouterLink"),l=d("ExternalLinkIcon");return s(),r("div",null,[_,u,p,t("p",null,[o(n,{to:"/api/api.html#eip712"},{default:c(()=>[e("在此了解更多关于EIP712交易的信息")]),_:1}),e(".")]),y,f,k,m,t("p",null,[e("要在zkSync Era上部署合同，用户调用"),o(n,{to:"/dev/building-on-zksync/contracts/.../.../developer-guides/system-contracts.html#contractdeployer"},{default:c(()=>[e("ContractDeployer系统合同")]),_:1}),e("的"),z,e("函数，提供要发布的合同的哈希值，以及构造器参数。合同字节码本身是在事务的"),b,e("字段中提供的（因为它是一个"),o(n,{to:"/dev/building-on-zksync/contracts/.../.../api/api.html#eip712"},{default:c(()=>[e("EIP712事务")]),_:1}),e("）。如果合同是一个工厂（即它可以部署其他合同），这些合同的字节码也应该包括在"),g,e("中。")]),L,t("p",null,[e("这里有一个"),o(n,{to:"/dev/building-on-zksync/contracts/.../.../.../api/hardhat/getting-started.html"},{default:c(()=>[e("关于如何使用它的分步指南")]),_:1}),e("。")]),v,E,t("p",null,[e("在引擎盖下，zkSync并不存储合约的字节码，而是"),x,e("。你可以看到，即使是"),o(n,{to:"/dev/building-on-zksync/contracts/.../.../developer-guides/system-contracts.html#contractdeployer"},{default:c(()=>[e("ContractDeployer")]),_:1}),e("系统合同也接受部署合同的字节码哈希值，而不是其字节码。然而，为了使合约部署成功，运营商需要知道字节码。正是由于这个原因，交易的"),S,e('（即工厂依赖）字段被使用：它包含了操作员应该知道的字节码，以便这个交易成功。一旦交易成功，这些字节码将被公布在L1上，并被视为永远被操作者 "知道"。')]),C,D,t("p",null,[e("这两个例子在我们的"),o(n,{to:"/dev/building-on-zksync/contracts/api/hardhat/getting-started.html"},{default:c(()=>[e("hardhat-zksync-deploy")]),_:1}),e("中已经无缝完成。")]),A,t("p",null,[e("为了便于"),o(n,{to:"/dev/building-on-zksync/contracts/developer-guides/aa.html"},{default:c(()=>[e("支持账户抽象")]),_:1}),e("，对于每个账户，我们将nonce分成两部分。部署nonce_和交易nonce_。部署nonce是该账户用`CREATE'操作码部署的合约数量，而交易nonce则用于交易的重放攻击保护。")]),t("p",null,[e("这意味着，虽然zkSync上的nonce与Ethereum上的行为方式相同，但对于EOA来说，计算部署合同的地址并不那么简单。在Ethereum上，它可以安全地计算为"),B,e("，而在zkSync上，建议等待合同部署，并捕捉由"),o(n,{to:"/dev/building-on-zksync/contracts/developer-guides/system-contracts.html#contractdeployer"},{default:c(()=>[e("ContractDeployer")]),_:1}),e("发出的"),I,e("事件，以获得新部署合同的地址。所有这些都是由SDK在后台完成的。")]),t("p",null,[e("为了获得一个确定的地址，你应该使用"),o(n,{to:"/dev/building-on-zksync/contracts/.../.../developer-guides/system-contracts.html#contractdeployer"},{default:c(()=>[e("ContractDeployer")]),_:1}),e("的"),V,e("方法。它也适用于EOA，但在SDK中还不能使用。")]),R,N,t("p",null,[e("用于提交L1->L2事务的"),t("a",P,[e("接口"),o(l)]),e("接受该特定事务所需的所有工厂依赖的列表。处理它们的逻辑与默认的L2部署是一样的。唯一的区别是，由于用户已经在L1上发布了字节码的完整预像，所以不需要在L1上再次发布这些字节码。")]),t("p",null,[e("要了解更多关于zkSync Era上的L1-L2通信，请访问"),o(n,{to:"/dev/building-on-zksync/contracts/.../.../developer-guides/bridging/l1-l2.html"},{default:c(()=>[e("本节文档")]),_:1})])])}const w=a(h,[["render",M],["__file","contract-deployment.html.vue"]]);export{w as default};
