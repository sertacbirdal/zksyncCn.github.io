import{_ as d,W as l,X as o,Z as e,$ as i,a0 as a,a2 as n,Y as s,D as r}from"./framework-674379d2.js";const c={},h=e("h1",{id:"衔接资产",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#衔接资产","aria-hidden":"true"},"#"),i(" 衔接资产")],-1),L=e("h2",{id:"介绍",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#介绍","aria-hidden":"true"},"#"),i(" 介绍")],-1),_=e("p",null,"开发者可以自由地为任何令牌建立自己的桥梁。 然而，我们提供了我们的默认桥接器（一个用于ETH，一个用于ERC20代币），可用于基本桥接。",-1),p=e("div",{class:"hint-container warning"},[e("p",{class:"hint-container-title"},"Note"),e("p",null,"L2上的代币的地址将总是与同一代币L1地址不同。")],-1),u=e("h2",{id:"默认桥接",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#默认桥接","aria-hidden":"true"},"#"),i(" 默认桥接")],-1),g=e("code",null,"zks_getBridgeContracts",-1),f=e("code",null,"Provider",-1),v=e("code",null,"getDefaultBridgeAddresses",-1),b=s('<h3 id="存款-到l2" tabindex="-1"><a class="header-anchor" href="#存款-到l2" aria-hidden="true">#</a> 存款(到L2)</h3><p>用户必须在L1桥梁合约上调用<code>deposit</code>方法，这将触发以下动作。</p><ul><li>用户的L1代币将被发送到L1桥，并在那里被锁定。</li><li>L1桥使用L1-&gt;L2通信向L2桥发起一个交易。</li><li>在L2交易中，代币将被铸造并被发送到L2上的指定地址。 <ul><li>如果该代币在zkSync上还不存在，就会为其部署一个新的合约。鉴于L2代币地址是确定的（基于原始L1地址、名称和符号），谁是第一个桥接它的人并不重要，新的L2地址将是相同的。</li></ul></li><li>对于每一个执行的L1-&gt;L2事务，都会有一个L2-&gt;L1的日志信息来确认其执行。</li><li>最后，<code>finalizeDeposit</code>方法被调用，它最终完成存款并在L2上铸造资金。</li></ul><div class="hint-container warning"><p class="hint-container-title">Note</p><p>如果这个交易由于任何原因而失败（例如，提供的费用太低），日志信息将说明其失败。 在这种情况下，可以在L1桥上证明日志的收录，通过调用<code>claimFailedDeposit</code>方法将存入的资金返还给原发件人。</p></div><p>上面描述的日志信息还没有被我们的SDK完全支持，但在L1桥的合约上可以使用。</p><h3 id="提款-到l1" tabindex="-1"><a class="header-anchor" href="#提款-到l1" aria-hidden="true">#</a> 提款(到L1)</h3><p>用户必须调用L2桥接合约上的<code>withdraw</code>方法，这将触发以下动作。</p><ul><li>L2代币将被烧毁。</li><li>将发送一条包含提款信息的L2-&gt;L1消息。</li><li>之后，提款行动将可由 L1 桥中的任何人完成（通过证明包含 L2 -&gt; L1 消息，这在调用 L1 桥合约上的 <code>finalizeWithdraw</code> 方法时完成）。</li><li>在该方法被调用后，资金从L1桥中解锁并发送给提款接收人。</li></ul><div class="hint-container warning"><p class="hint-container-title">Note</p><p>在testnet环境下，我们会自动敲定所有的提款，也就是说，对于每一笔提款，我们都会通过做L1交易来处理，证明每条信息的包含。</p></div>',9);function m(x,w){const t=r("RouterLink");return l(),o("div",null,[h,L,e("p",null,[i("桥接是通过两个合约来实现的 (一个部署在L1，另一个部署在L2) 使用"),a(t,{to:"/dev/developer-guides/bridging/l1-l2-interop.html"},{default:n(()=>[i("L1 <-> L2 interoperability")]),_:1}),i("相互通信。")]),_,p,u,e("p",null,[i("你可以使用"),g,i("端点或我们的"),a(t,{to:"/dev/developer-guides/bridging/.../.../api/js/"},{default:n(()=>[i("Javascript SDK")]),_:1}),i("中"),f,i("的"),v,i("方法获得默认桥的地址（其他SDK中也有类似方法）。")]),b])}const N=d(c,[["render",m],["__file","bridging-asset.html.vue"]]);export{N as default};
